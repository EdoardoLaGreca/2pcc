# Intermediate representation

The intermediate representation, from now on shortened as *IR*, has the duty to represent the code in a fairly low level way while being platform-independent. It is textual and can contain specifiers where necessary, nothing is left to interpretations.

Keep In mind that the IR language is designed to be generated by computers, it is not intended to be used by humans.

NB1: If multiple IR statements are specified and one or more parameters have the same name, they also have the same values.

NB2: If an IR statement takes two parameters and the length in memory of the two parameters is not the same, it is a bug. This is not supposed to happen.

NB3: Whenever an existing variable name is required, a constant value may be placed as well, if it makes sense. This means that this rule is valid for all the existing statements except for `push` and `func`.

## Comments

Mulit-line comments do not exist. All the comments are single-line, they start with `#` and end at the end of the line (`\n`).

```
# comment example
```

## Variables

### Stack allocation

```
(push NAME LENGTH)
```

where:

 - `NAME` is the variable's name
 - `LENGTH` is an integer that represents the amount of bytes allocated in the stack for that variable

Variables allocated inside of a scope, such as a function, must be deallocated at the end of that scope (see `pop`).

### Assignment

```
(assign NAME1 NAME2)
```

where:

 - `NAME1` is the variable name in which the new value is placed (cannot be a constant)
 - `NAME2` the variable name which contains the new value (can be a constant)

Variables can be assigned only *after* allocation.

### Stack deallocation

```
(pop N)
```

where:

 - `N` is the amount of variables to pop from the stack (acts like multiple `pop`s)

## Labels

```
(label NAME)
```

where:

 - `NAME` is the label name

## Go-to's

```
(goto NAME)
```

where:

 - `NAME` is the label name to go to

## Conditions

```
(cond NAME1 NAME2 CMP)
```

where:

 - `NAME1` and `NAME2` are the names of the variables to be compared
 - `CMP` is the comparison operator: "eq" is *equal*, "ne" is *not equal*, "gt" is *greater than*, "lt" is *less than*, "ge" is *greater or equal to* and "le" is *less or equal to*

Conditions do not do anything unless they are inside of another statement.

## Conditional statements

### If statement

```
(if COND LABEL)
```

where:

 - `COND` is the condition
 - `LABEL` is the label to go to if the condition is true

### If-else statement

```
(ifelse COND LABEL1 LABEL2)
```

where:

 - `COND` is the condition
 - `LABEL1` is the label to go to if the condition is true
 - `LABEL2` is the label to go to if the condition is false

## Operators

### Arithmetic operators

If an operation ends with "u", it means that it considers the operands as unsigned.

#### Addition

```
(add NAME1 NAME2)
(addu NAME1 NAME2)
```

where:

 - `NAME1` is the first operand's name, which is also where the result will be stored
 - `NAME2` is the second operand's name

#### Subtraction

```
(sub NAME1 NAME2)
(subu NAME1 NAME2)
```

where:

 - `NAME1` is the first operand's name, which is also where the result will be stored
 - `NAME2` is the second operand's name

#### Negation

```
(neg NAME)
```

where:

 - `NAME` is the operand name

#### Multiplication

```
(mul NAME1 NAME2)
(mulu NAME1 NAME2)
```

where:

 - `NAME1` is the first operand's name, which is also where the result will be stored
 - `NAME2` is the second operand's name

#### Division

```
(div NAME1 NAME2)
(divu NAME1 NAME2)
```

where:

 - `NAME1` is the first operand's name, which is also where the result will be stored
 - `NAME2` is the second operand's name

#### Modulo

```
(mod NAME1 NAME2)
(modu NAME1 NAME2)
```

where:

 - `NAME1` is the first operand's name, which is also where the result will be stored
 - `NAME2` is the second operand's name

#### Increment

```
(inc NAME)
(incu NAME)
```

where:

 - `NAME` is the operand name

#### Decrement

```
(dec NAME)
(decu NAME)
```

where:

 - `NAME` is the operand name

### Logical operators

#### Logical negation

```
(lognot NAME)
```

where:

 - `NAME` is the operand name

#### Logical AND

```
(logand NAME1 NAME2)
```

where:

 - `NAME1` and `NAME2` are operand names

#### Logical OR

```
(logor NAME1 NAME2)
```

where:

 - `NAME1` and `NAME2` are operand names

### Bitwise operators

#### Bitwise NOT

```
(bitnot NAME)
```

where:

 - `NAME` is the operand name

#### Bitwise AND

```
(bitand NAME1 NAME2)
```

where:

 - `NAME1` and `NAME2` are operand names

#### Bitwise OR

```
(bitor NAME1 NAME2)
```

where:

 - `NAME1` and `NAME2` are operand names

#### Bitwise XOR

```
(bitxor NAME1 NAME2)
```

where:

 - `NAME1` and `NAME2` are operand names

#### Bitwise left shift

```
(bitlsh NAME NUM)
```

where:

 - `NAME` is the variable name
 - `NUM` is the amount of bits to shift

#### Bitwise right shift

```
(bitrsh NAME NUM)
```

where:

 - `NAME` is the variable name
 - `NUM` is the amount of bits to shift

## Functions

### Function declaration/definition

```
(func NAME RETLEN ANAME1 ALEN1 ANAME2 ALEN2 ... ANAMEN ALENN)
...
(ret RETNAME)
```

where:

 - `NAME` is the function name
 - `RETLEN` is the return type's length in bytes
 - `RETNAME` is the name of the value which is returned
 - `ANAME1`, `ANAME2`, `ANAMEN` are the names of the arguments
 - `ALEN1`, `ALEN2`, `ALENN` are the lengths of the values of the arguments

In case of functions whose return type is `void`, `RETLEN` is 0 and `RETNAME` is omitted (just `(ret)`).

The realizer will follow a particular [calling convention](https://en.wikipedia.org/wiki/Calling_convention) depending on which CPU architecture is targeted.

### Internal function calling

```
(call NAME ANAME1 ALEN1 ANAME2 ALEN2 ... ANAMEN ALENN)
```

where:

 - `NAME` is the function name
 - `ANAME1`, `ANAME2`, `ANAMEN` are the names of the variables which contain the values of the arguments
 - `ALEN1`, `ALEN2`, `ALENN` are the lengths of the values of the arguments

### External function calling

```
(extcall NAME ANAME1 ALEN1 ANAME2 ALEN2 ... ANAMEN ALENN)
```

where:

 - `NAME` is the function name
 - `ANAME1`, `ANAME2`, `ANAMEN` are the names of the variables which contain the values of the arguments
 - `ALEN1`, `ALEN2`, `ALENN` are the lengths of the values of the arguments

## Possible implementations

The IR does not provide every possible statement. However, in this section are listed possible implementations of non-existing statements. It is strongly recommended that these implementation are used (instead of creating new ones) to ease the development of realizers, especially for CISC architectures.

### Loops

#### While loop

```
(label NAME1)
(if NCOND NAME2)
...
(goto NAME1)
(label NAME2)
```

Where `NCOND` is the negated loop condition.

#### For loop

```
(push NAME1 LENGTH)
(push NAME2 LENGTH)

(assign NAME1 0)
(assign NAME2 VALUE)

(label LABEL1)
(if (cond NAME1 NAME2 ge) LABEL2)
...
(inc NAME1)
(goto LABEL1)
(label LABEL2)
```

The condition in the `if` statement is negated so that if it is true it breaks the loop. This implementation is a modified version of the one in the while loop.

