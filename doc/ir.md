# Intermediate representation

The intermediate representation, from now on shortened as *IR*, has the duty to represent the code in a fairly low level way while being platform-independent. It is textual and can contain specifiers where necessary, nothing is left to interpretations.

Keep In mind that the IR language is designed to be generated by computers, it is not intended to be used by humans.

NB1: An IR statement's values are always constants, unless otherwise written.

NB2: If multiple IR statements are specified and one or more parameters have the same name, they also have the same values.

NB3: If an IR statement takes two parameters and the length of the two parameters is not the same, it is a bug. This is not supposed to happen.

NB4: All the addresses are relative to the stack base, which means that the stack base (first byte) has address 0x00, the second byte allocated has address 0x01, etc.

## Comments

Mulit-line comments do not exist. All the comments are single-line, they start with `#` and end at the end of the line (`\n`).

```
# example of a comment
```

## Variables

### Allocation/Declaration

```
(salloc LENGTH) # NAME ADDR
```

where:

 - `NAME` is the variable's name
 - `LENGTH` is an integer that represents the number of bytes allocated in the stack for that variable
 - `ADDR` is the address of the first byte of the variable

NAME and ADDR are specified as a comment because they are not needed by the IR but they can be useful in case of debugging.

Variables declared inside of a scope, such as a function, must be deallocated at the end of that scope.

### Assignment

```
(assign ADDR VALUE)
```

where:

 - `ADDR` is the address of the variable
 - `VALUE` is the new value of the variable

Variables can be assigned only *after* allocation.

## Labels

```
(label NAME)
```

where:

 - `NAME` is the label name

## Go-to's

```
(goto NAME)
```

where:

 - `NAME` is the label name to go to

## Conditions

```
(cond ADDR1 ADDR2 CMP)
```

where:

 - `ADDR1` and `ADDR2` are the addresses of the variables to be compared
 - `CMP` is the comparison operator: "eq" is *equal*, "ne" is *not equal*, "gt" is *greater than*, "lt" is *less than*, "ge" is *greater or equal to* and "le" is *less or equal to*

Conditions do not do anything unless they are inside of another statement.

## Conditional statements

### If statement

```
(if COND LABEL)
```

where:

 - `COND` is the condition
 - `LABEL` is the label to go to if the condition is true

### If-else statement

```
(ifelse COND LABEL1 LABEL2)
```

where:

 - `COND` is the condition
 - `LABEL1` is the label to go to if the condition is true
 - `LABEL2` is the label to go to if the condition is false

## Operators

### Arithmetic operators

If an operation ends with "u", it means that it considers the operands as unsigned.

#### Addition

```
(add ADDR1 ADDR2)
(addu ADDR1 ADDR2)
```

where:

 - `ADDR1` is the address of the first number, which is also where the result will be stored
 - `ADDR2` is the address of the second number

#### Subtraction

```
(sub ADDR1 ADDR2)
(subu ADDR1 ADDR2)
```

where:

 - `ADDR1` is the address of the first number, which is also where the result will be stored
 - `ADDR2` is the address of the second number

#### Negation

```
(neg ADDR)
```

where:

 - `ADDR` is the address of the number to negate

#### Multiplication

```
(mul ADDR1 ADDR2)
(mulu ADDR1 ADDR2)
```

where:

 - `ADDR1` is the address of the first number, which is also where the result will be stored
 - `ADDR2` is the address of the second number

#### Division

```
(div ADDR1 ADDR2)
(divu ADDR1 ADDR2)
```

where:

 - `ADDR1` is the address of the first number, which is also where the result will be stored
 - `ADDR2` is the address of the second number

#### Modulo

```
(mod ADDR1 ADDR2)
(modu ADDR1 ADDR2)
```

where:

 - `ADDR1` is the address of the first number, which is also where the result will be stored
 - `ADDR2` is the address of the second number

#### Increment

```
(inc ADDR)
(incu ADDR)
```

where:

 - `ADDR` is the address of the number

#### Decrement

```
(dec ADDR)
(decu ADDR)
```

where:

 - `ADDR` is the address of the number

### Logical operators

#### Logical negation

```
(lognot ADDR)
```

where:

 - `ADDR` is the address of the variable

#### Logical AND

```
(logand ADDR1 ADDR2)
```

where:

 - `ADDR1` and `ADDR2` are the addresses of the variables

#### Logical OR

```
(logor ADDR1 ADDR2)
```

where:

 - `ADDR1` and `ADDR2` are the addresses of the variables

### Bitwise operators

#### Bitwise NOT

```
(bitnot ADDR)
```

where:

 - `ADDR` is the address of the variable

#### Bitwise AND

```
(bitand ADDR1 ADDR2)
```

where:

 - `ADDR1` and `ADDR2` are the addresses of the variables

#### Bitwise OR

```
(bitor ADDR1 ADDR2)
```

where:

 - `ADDR1` and `ADDR2` are the addresses of the variables

#### Bitwise XOR

```
(bitxor ADDR1 ADDR2)
```

where:

 - `ADDR1` and `ADDR2` are the addresses of the variables

#### Bitwise left shift

```
(bitlsh ADDR NUM)
```

where:

 - `ADDR` is the address of the variable
 - `NUM` is the number of bits to shift

#### Bitwise right shift

```
(bitrsh ADDR NUM)
```

where:

 - `ADDR` is the address of the variable
 - `NUM` is the number of bits to shift

## Functions

### Function declaration/definition

```
(func NAME RETLEN PARAMLEN)
...
(ret RETADDR)
```

where:

 - `NAME` is the function name
 - `RETLEN` is the return type's length in bytes
 - `PARAMLEN` is the sum of the parameter lengths in bytes
 - `RETADDR` is the returned variable's address

The `func` statement is followed by, in this order:

 1. the allocation of the function parameters
 2. the initialization of the function parameters
 3. the allocation of the function's local variables
 4. the initialization of the function's local variables
 5. the function code
 6. the `ret` statement

### Function calling

```
(call NAME ADDR)
```

where:

 - `NAME` is the function name
 - `ADDR` is the address where the returned value is stored

## Possible implementations

The IR does not provide every possible statement. However, in this section are listed possible implementations of non-existing statements. It is strongly recommended that these implementation are used (instead of creating new ones) to ease the development of realizers, especially for CISC architectures.

### Loops

#### While loop

```
(label NAME1)
(if NCOND NAME2)
...
(goto NAME1)
(label NAME2)
```

Where `NCOND` is the negated loop condition.

#### For loop

```
(salloc LENGTH) # NAME1 ADDR1
(salloc LENGTH) # NAME2 ADDR2

(assign ADDR1 0)
(assign ADDR2 VALUE)

(label NAME3)
(if (cond ADDR1 ADDR2 ge) NAME1)
...
(inc ADDR1)
(goto NAME3)
(label NAME1)
```

The condition in the `if` statement is negated so that if it is true it breaks the loop. This implementation is a modified version of the one in the while loop.

